package lightstep

import (
	"fmt"
	"log"
	"math/rand"
	"os"
	"path"
	"runtime"
	"strings"
	"sync"
	"time"

	"golang.org/x/net/context"

	"google.golang.org/grpc"

	// N.B.(jmacd): Do not use google.golang.org/glog in this package.

	cpb "github.com/lightstep/lightstep-tracer-go/collectorpb"
	"github.com/lightstep/lightstep-tracer-go/lightstep_thrift"
	ot "github.com/opentracing/opentracing-go"
)

type Connection interface {
	Close() error
}

type Command struct {
	Disabled bool
}

type CollectorResponse struct {
	Errors   []string
	Commands []*Command
}

type CollectorClient interface {
	Report(context.Context, *reportBuffer) (*CollectorResponse, error)
	ConnectClient() (Connection, error)
}

// GrpcOptions control how the LightStep Tracer behaves.
type Options struct {
	// AccessToken is the unique API key for your LightStep project.  It is
	// available on your account page at https://app.lightstep.com/account
	AccessToken string `yaml:"access_token" usage:"access token for reporting to LightStep"`

	// Collector is the host, port, and plaintext option to use
	// for the collector.
	Collector Endpoint `yaml:"collector"`

	// Tags are arbitrary key-value pairs that apply to all spans generated by
	// this Tracer.
	Tags ot.Tags

	// LightStep is the host, port, and plaintext option to use
	// for the LightStep web API.
	LightStepAPI Endpoint `yaml:"lightstep_api"`

	// MaxBufferedSpans is the maximum number of spans that will be buffered
	// before sending them to a collector.
	MaxBufferedSpans int `yaml:"max_buffered_spans"`

	// MaxLogKeyLen is the maximum allowable size (in characters) of an
	// OpenTracing logging key. Longer keys are truncated.
	MaxLogKeyLen int `yaml:"max_log_key_len"`

	// MaxLogValueLen is the maximum allowable size (in characters) of an
	// OpenTracing logging value. Longer values are truncated. Only applies to
	// variable-length value types (strings, interface{}, etc).
	MaxLogValueLen int `yaml:"max_log_value_len"`

	// MaxLogsPerSpan limits the number of logs in a single span.
	MaxLogsPerSpan int `yaml:"max_logs_per_span"`

	// ReportingPeriod is the maximum duration of time between sending spans
	// to a collector.  If zero, the default will be used.
	ReportingPeriod time.Duration `yaml:"reporting_period"`

	ReportTimeout time.Duration `yaml:"report_timeout"`

	// DropSpanLogs turns log events on all Spans into no-ops.
	DropSpanLogs bool `yaml:"drop_span_logs"`

	// Set Verbose to true to enable more text logging.
	Verbose bool `yaml:"verbose"`

	// DEPRECATED: set `UseThrift` to true if you do not want gRPC
	UseGRPC bool `yaml:"usegrpc"`

	// Switch to
	UseThrift bool `yaml:"use_thrift"`

	ReconnectPeriod time.Duration `yaml:"reconnect_period"`

	// For testing purposes only
	GrpcConnector func() (GrpcConnection, cpb.CollectorServiceClient, error)

	// For testing purposes only
	ThriftConnector func() lightstep_thrift.ReportingService
}

func (opts *Options) setDefaults() {
	// Note: opts is a copy of the user's data, ok to modify.
	if opts.MaxBufferedSpans == 0 {
		opts.MaxBufferedSpans = defaultMaxSpans
	}
	if opts.MaxLogKeyLen == 0 {
		opts.MaxLogKeyLen = defaultMaxLogKeyLen
	}
	if opts.MaxLogValueLen == 0 {
		opts.MaxLogValueLen = defaultMaxLogValueLen
	}
	if opts.MaxLogsPerSpan == 0 {
		opts.MaxLogsPerSpan = defaultMaxLogsPerSpan
	}
	if opts.ReportingPeriod == 0 {
		opts.ReportingPeriod = defaultMaxReportingPeriod
	}
	if opts.ReportTimeout == 0 {
		opts.ReportTimeout = defaultReportTimeout
	}
	if opts.ReconnectPeriod == 0 {
		opts.ReconnectPeriod = defaultReconnectPeriod
	}
}

// Recorder buffers spans and forwards them to a LightStep collector.
type LightStepRecorder struct {
	lock sync.Mutex

	// Note: the following are divided into immutable fields and
	// mutable fields. The mutable fields are modified under `lock`.

	//////////////////////////////////////////////////////////////
	// IMMUTABLE IMMUTABLE IMMUTABLE IMMUTABLE IMMUTABLE IMMUTABLE
	//////////////////////////////////////////////////////////////

	// Note: there may be a desire to update some of these fields
	// at runtime, in which case suitable changes may be needed
	// for variables accessed during Flush.

	// auth and runtime information
	attributes map[string]string
	startTime  time.Time

	// apiURL is the base URL of the LightStep web API, used for
	// explicit trace collection requests.
	apiURL string

	// accessToken is the access token used for explicit trace
	// collection requests.
	accessToken string

	reporterID         uint64        // the LightStep tracer guid
	verbose            bool          // whether to print verbose messages
	maxLogKeyLen       int           // see GrpcOptions.MaxLogKeyLen
	maxLogValueLen     int           // see GrpcOptions.MaxLogValueLen
	maxReportingPeriod time.Duration // set by GrpcOptions.MaxReportingPeriod
	reconnectPeriod    time.Duration // set by GrpcOptions.ReconnectPeriod
	reportingTimeout   time.Duration // set by GrpcOptions.ReportTimeout

	// Remote service that will receive reports.
	hostPort      string
	backend       CollectorClient
	conn          Connection
	connTimestamp time.Time
	creds         grpc.DialOption
	closech       chan struct{}

	//////////////////////////////////////////////////////////
	// MUTABLE MUTABLE MUTABLE MUTABLE MUTABLE MUTABLE MUTABLE
	//////////////////////////////////////////////////////////

	// Two buffers of data.
	buffer   reportBuffer
	flushing reportBuffer

	// Flush state.
	reportInFlight    bool
	lastReportAttempt time.Time

	// We allow our remote peer to disable this instrumentation at any
	// time, turning all potentially costly runtime operations into
	// no-ops.
	//
	// TODO this should use atomic load/store to test disabled
	// prior to taking the lock, do please.
	disabled bool

	opts Options
}

func NewLightStepRecorder(opts Options) *LightStepRecorder {
	opts.setDefaults()
	if len(opts.AccessToken) == 0 {
		fmt.Println("LightStep Recorder options.AccessToken must not be empty")
		return nil
	}
	if opts.Tags == nil {
		opts.Tags = make(map[string]interface{})
	}
	// Set some default attributes if not found in options
	if _, found := opts.Tags[ComponentNameKey]; !found {
		opts.Tags[ComponentNameKey] = path.Base(os.Args[0])
	}
	if _, found := opts.Tags[GUIDKey]; found {
		fmt.Printf("Passing in your own %v is no longer supported\n", GUIDKey)
	}
	if _, found := opts.Tags[HostnameKey]; !found {
		hostname, _ := os.Hostname()
		opts.Tags[HostnameKey] = hostname
	}
	if _, found := opts.Tags[CommandLineKey]; !found {
		opts.Tags[CommandLineKey] = strings.Join(os.Args, " ")
	}

	attributes := make(map[string]string)
	for k, v := range opts.Tags {
		attributes[k] = fmt.Sprint(v)
	}
	// Don't let the GrpcOptions override these values. That would be confusing.
	attributes[TracerPlatformKey] = TracerPlatformValue
	attributes[TracerPlatformVersionKey] = runtime.Version()
	attributes[TracerVersionKey] = TracerVersionValue

	now := time.Now()
	rec := &LightStepRecorder{
		accessToken:        opts.AccessToken,
		attributes:         attributes,
		startTime:          now,
		maxReportingPeriod: defaultMaxReportingPeriod,
		reportingTimeout:   opts.ReportTimeout,
		verbose:            opts.Verbose,
		maxLogKeyLen:       opts.MaxLogKeyLen,
		maxLogValueLen:     opts.MaxLogValueLen,
		apiURL:             getLSAPIURL(opts),
		reporterID:         genSeededGUID(),
		buffer:             newSpansBuffer(opts.MaxBufferedSpans),
		flushing:           newSpansBuffer(opts.MaxBufferedSpans),
		hostPort:           getLSCollectorHostPort(opts),
		reconnectPeriod:    time.Duration(float64(opts.ReconnectPeriod) * (1 + 0.2*rand.Float64())),
		opts:               opts,
	}

	rec.buffer.setCurrent(now)

	// TODO implement use_thrift and the defaul grpc
	if opts.UseThrift {
		rec.backend = NewThriftRecorder(opts)
	} else {
		rec.backend = NewRecorder(opts)
	}

	conn, err := rec.backend.ConnectClient()

	if err != nil {
		fmt.Println("grpc.Dial failed permanently:", err)
		return nil
	}

	rec.conn = conn
	rec.connTimestamp = now
	rec.closech = make(chan struct{})

	go rec.reportLoop(rec.closech)

	return rec
}

func (r *LightStepRecorder) connectClient() (GrpcConnection, cpb.CollectorServiceClient, error) {
	conn, err := grpc.Dial(r.hostPort, r.creds)
	if err != nil {
		return nil, nil, err
	}
	return conn, cpb.NewCollectorServiceClient(conn), nil
}

func (r *LightStepRecorder) reconnectClient(now time.Time) {
	conn, err := r.backend.ConnectClient()
	if err != nil {
		r.maybeLogInfof("could not reconnect client")
	} else {
		r.lock.Lock()
		oldConn := r.conn
		r.conn = conn
		r.connTimestamp = now
		r.lock.Unlock()

		oldConn.Close()
		r.maybeLogInfof("reconnected client connection")
	}
}

func (r *LightStepRecorder) ReporterID() uint64 {
	return r.reporterID
}

func (r *LightStepRecorder) Close() error {
	r.lock.Lock()
	conn := r.conn
	closech := r.closech
	r.conn = nil
	r.closech = nil
	r.lock.Unlock()

	if closech != nil {
		close(closech)
	}

	if conn == nil {
		return nil
	}
	return conn.Close()
}

func (r *LightStepRecorder) RecordSpan(raw RawSpan) {
	r.lock.Lock()
	defer r.lock.Unlock()

	// Early-out for disabled runtimes
	if r.disabled {
		return
	}

	r.buffer.addSpan(raw)
}

func (r *LightStepRecorder) Flush() {
	r.lock.Lock()

	if r.disabled {
		r.lock.Unlock()
		return
	}

	if r.conn == nil {
		r.maybeLogError(errConnectionWasClosed)
		r.lock.Unlock()
		return
	}

	if r.reportInFlight == true {
		r.maybeLogError(errPreviousReportInFlight)
		r.lock.Unlock()
		return
	}

	// There is not an in-flight report, therefore r.flushing has been reset and
	// is ready to re-use.
	now := time.Now()
	r.buffer, r.flushing = r.flushing, r.buffer
	r.reportInFlight = true
	r.flushing.setFlushing(now)
	r.buffer.setCurrent(now)
	r.lastReportAttempt = now
	r.lock.Unlock()

	ctx, cancel := context.WithTimeout(context.Background(), r.reportingTimeout)
	defer cancel()
	// NOTE: Where the magic happens
	resp, err := r.backend.Report(ctx, &r.flushing)

	if err != nil {
		r.maybeLogError(err)
	} else if len(resp.Errors) > 0 {
		// These should never occur, since this library should understand what
		// makes for valid logs and spans, but just in case, log it anyway.
		for _, err := range resp.Errors {
			r.maybeLogError(fmt.Errorf("Remote report returned error: %s", err))
		}
	} else {
		r.maybeLogInfof("Report: resp=%v, err=%v", resp, err)
	}

	var droppedSent int64
	r.lock.Lock()
	r.reportInFlight = false
	if err != nil {
		// Restore the records that did not get sent correctly
		r.buffer.mergeFrom(&r.flushing)
	} else {
		droppedSent = r.flushing.droppedSpanCount
		r.flushing.clear()
	}
	r.lock.Unlock()

	if droppedSent != 0 {
		r.maybeLogInfof("client reported %d dropped spans", droppedSent)
	}

	if err != nil {
		return
	}
	for _, c := range resp.Commands {
		if c.Disabled {
			r.Disable()
		}
	}
}

func (r *LightStepRecorder) Disable() {
	r.lock.Lock()
	defer r.lock.Unlock()

	if r.disabled {
		return
	}

	fmt.Printf("Disabling Runtime instance: %p", r)

	r.buffer.clear()
	r.disabled = true
}

// Every minReportingPeriod the reporting loop wakes up and checks to see if
// either (a) the Runtime's max reporting period is about to expire (see
// maxReportingPeriod()), (b) the number of buffered log records is
// approaching kMaxBufferedLogs, or if (c) the number of buffered span records
// is approaching kMaxBufferedSpans. If any of those conditions are true,
// pending data is flushed to the remote peer. If not, the reporting loop waits
// until the next cycle. See Runtime.maybeFlush() for details.
//
// This could alternatively be implemented using flush channels and so forth,
// but that would introduce opportunities for client code to block on the
// runtime library, and we want to avoid that at all costs (even dropping data,
// which can certainly happen with high data rates and/or unresponsive remote
// peers).
func (r *LightStepRecorder) shouldFlushLocked(now time.Time) bool {
	if now.Add(minReportingPeriod).Sub(r.lastReportAttempt) > r.maxReportingPeriod {
		// Flush timeout.
		r.maybeLogInfof("--> timeout")
		return true
	} else if r.buffer.isHalfFull() {
		// Too many queued span records.
		r.maybeLogInfof("--> span queue")
		return true
	}
	return false
}

func (r *LightStepRecorder) reportLoop(closech chan struct{}) {
	tickerChan := time.Tick(minReportingPeriod)
	for {
		select {
		case <-tickerChan:
			now := time.Now()

			r.lock.Lock()
			disabled := r.disabled
			reconnect := !r.reportInFlight && now.Sub(r.connTimestamp) > r.reconnectPeriod
			shouldFlush := r.shouldFlushLocked(now)
			r.lock.Unlock()

			if disabled {
				return
			}
			if shouldFlush {
				r.Flush()
			}
			if reconnect {
				r.reconnectClient(now)
			}
		case <-closech:
			r.Flush()
			return
		}
	}
}

// maybeLogError logs the first error it receives using the standard log
// package and may also log subsequent errors based on verboseFlag.
func (r *LightStepRecorder) maybeLogError(err error) {
	if r.verbose {
		log.Printf("LightStep error: %v\n", err)
	} else {
		// Even if the flag is not set, always log at least one error.
		logOneError.Do(func() {
			log.Printf("LightStep instrumentation error (%v). Set the Verbose option to enable more logging.\n", err)
		})
	}
}

// maybeLogInfof may format and log its arguments if verboseFlag is set.
func (r *LightStepRecorder) maybeLogInfof(format string, args ...interface{}) {
	if r.verbose {
		s := fmt.Sprintf(format, args...)
		log.Printf("LightStep info: %s\n", s)
	}
}

func getLSCollectorHostPort(opts Options) string {
	e := opts.Collector
	host := e.Host
	if host == "" {
		if opts.UseGRPC {
			host = defaultGRPCCollectorHost
		} else {
			host = defaultCollectorHost
		}
	}
	port := e.Port
	if port <= 0 {
		if e.Plaintext {
			port = defaultPlainPort
		} else {
			port = defaultSecurePort
		}
	}
	return fmt.Sprintf("%s:%d", host, port)
}

func getLSCollectorURL(opts Options) string {
	// TODO This is dead code, remove?
	return getLSURL(opts.Collector,
		defaultCollectorHost,
		collectorPath)
}

func getLSAPIURL(opts Options) string {
	return getLSURL(opts.LightStepAPI, defaultAPIHost, "")
}

func getLSURL(e Endpoint, host, path string) string {
	if e.Host != "" {
		host = e.Host
	}
	httpProtocol := "https"
	port := defaultSecurePort
	if e.Plaintext {
		httpProtocol = "http"
		port = defaultPlainPort
	}
	if e.Port > 0 {
		port = e.Port
	}
	return fmt.Sprintf("%s://%s:%d%s", httpProtocol, host, port, path)
}
